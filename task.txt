

вот все мое тз:«Система турагенство». Заказчик выбирает и оплачивает Тур (отдых, экскурсия, шоппинг). Турагент определяет тур как «горящий», размеры скидок постоянным клиентам.
---


на основании тз я придумал это,

таблицу со списком туров (название тура, дата отправления и прибытия, место отправления, место тура, текстовое поле с названием tour_type, пометка горящий тур или нет, цена тура, цена тура со скидкой (указывать цену со скидкой не обязательно))

 2 user role (agent, customer)

можно зарегистрироваться (ввод email, пароля, имени, фамилии, отчества, телефона) и войти в аккаунт для роли customer
agent может только войти в аккаунт

после логина бэк возвращает токен,roleName, массив айдишников купленных туров (если туров не было куплено, массив пустой). 

действия доступные без токена всем пользователям даже незалогининым: получение списка туров

действия доступные с токеном agent: изменнение туров, их добавление и удаление, пополнение счета customer деньгами (просто добавление цифр через post)

действия доступные с токеном customer: выбор и оплата тура (оплата это списание средств со счета, если денег не хватает, выводится сообщение "Недостаточно средств на счете"), после оплаты тура в массив купленных туров добавляется айдишник купленного тура

 чтобы agent мог смотреть заказанные туры (сделай соответствующую таблицу)

index.js

const express = require('express');
const cors = require('cors');
const { Sequelize, DataTypes } = require('sequelize');

const app = express();

app.use(cors());
app.use(express.json());

const sequelize = new Sequelize('travel_agency_db', 'root', '', {
    host: '127.0.0.1',
    port: 3307,
    dialect: 'mysql',
    logging: false
});

const User = sequelize.define('User', {
    email: { type: DataTypes.STRING, unique: true, allowNull: false },
    password: { type: DataTypes.STRING, allowNull: false },
    role: { type: DataTypes.STRING, allowNull: false },
    name: { type: DataTypes.STRING },
    surname: { type: DataTypes.STRING },
    patronymic: { type: DataTypes.STRING },
    phone: { type: DataTypes.STRING },
    balance: { type: DataTypes.FLOAT, defaultValue: 0 }
});

const Tour = sequelize.define('Tour', {
    name: { type: DataTypes.STRING, allowNull: false },
    dateStart: { type: DataTypes.STRING, allowNull: false },
    dateEnd: { type: DataTypes.STRING, allowNull: false },
    origin: { type: DataTypes.STRING, allowNull: false },
    destination: { type: DataTypes.STRING, allowNull: false },
    tour_type: { type: DataTypes.STRING, allowNull: false },
    isHot: { type: DataTypes.BOOLEAN, defaultValue: false },
    price: { type: DataTypes.FLOAT, allowNull: false },
    discountPrice: { type: DataTypes.FLOAT, allowNull: true }
});

const Order = sequelize.define('Order', {});

User.hasMany(Order);
Order.belongsTo(User);
Tour.hasMany(Order);
Order.belongsTo(Tour);

const authMiddleware = async (req, res, next) => {
    const token = req.headers.authorization;
    if (!token) return res.status(401).json({ message: 'No token' });

    const [id, role] = token.split('-');
    const user = await User.findByPk(id);

    if (!user) return res.status(401).json({ message: 'Invalid token' });

    req.user = user;
    next();
};

const checkRole = (role) => (req, res, next) => {
    if (req.user.role !== role) {
        return res.status(403).json({ message: 'Access denied' });
    }
    next();
};

app.post('/register', async (req, res) => {
    try {
        const { email, password, name, surname, patronymic, phone } = req.body;
        const user = await User.create({
            email, password, name, surname, patronymic, phone, role: 'customer', balance: 0
        });
        res.json({ message: 'Registered successfully' });
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await User.findOne({ where: { email, password } });

        if (!user) return res.status(400).json({ message: 'User not found' });

        const orders = await Order.findAll({ where: { UserId: user.id } });
        const purchasedTourIds = orders.map(o => o.TourId);

        res.json({
            token: `${user.id}-${user.role}`,
            roleName: user.role,
            purchasedTourIds
        });
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.get('/tours', async (req, res) => {
    const tours = await Tour.findAll();
    res.json(tours);
});

app.post('/tours', authMiddleware, checkRole('agent'), async (req, res) => {
    try {
        const tour = await Tour.create(req.body);
        res.json(tour);
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.put('/tours/:id', authMiddleware, checkRole('agent'), async (req, res) => {
    try {
        await Tour.update(req.body, { where: { id: req.params.id } });
        res.json({ message: 'Updated' });
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.delete('/tours/:id', authMiddleware, checkRole('agent'), async (req, res) => {
    try {
        await Tour.destroy({ where: { id: req.params.id } });
        res.json({ message: 'Deleted' });
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.post('/balance', authMiddleware, checkRole('agent'), async (req, res) => {
    try {
        const { userId, amount } = req.body;
        const user = await User.findByPk(userId);
        if (!user) return res.status(404).json({ message: 'User not found' });

        user.balance += Number(amount);
        await user.save();
        res.json({ message: 'Balance updated', balance: user.balance });
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.get('/orders', authMiddleware, checkRole('agent'), async (req, res) => {
    try {
        const orders = await Order.findAll({
            include: [User, Tour]
        });
        res.json(orders);
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

app.post('/buy', authMiddleware, checkRole('customer'), async (req, res) => {
    try {
        const { tourId } = req.body;
        const tour = await Tour.findByPk(tourId);

        if (!tour) return res.status(404).json({ message: 'Tour not found' });

        const priceToPay = tour.discountPrice || tour.price;

        if (req.user.balance < priceToPay) {
            return res.status(400).json({ message: 'Недостаточно средств на счете' });
        }

        req.user.balance -= priceToPay;
        await req.user.save();

        await Order.create({ UserId: req.user.id, TourId: tour.id });

        res.json({ message: 'Tour purchased', tourId: tour.id });
    } catch (e) {
        res.status(500).json({ message: e.message });
    }
});

const start = async () => {
    try {
        await sequelize.authenticate();
        await sequelize.sync({ force: true });

        await User.create({
            email: 'agent@mail.com',
            password: 'admin',
            role: 'agent',
            name: 'Дмитрий',
            surname: 'Петров',
            balance: 0
        });

        await User.create({
            email: 'user@mail.com',
            password: '123',
            role: 'customer',
            name: 'Иван',
            surname: 'Иванов',
            balance: 50000
        });

        await Tour.bulkCreate([
            {
                name: 'Египет Все Включено',
                dateStart: '2026-03-01',
                dateEnd: '2026-03-10',
                origin: 'Минск',
                destination: 'Хургада',
                tour_type: 'Отдых',
                isHot: true,
                price: 45000,
                discountPrice: 39000
            },
            {
                name: 'Шоппинг в Милане',
                dateStart: '2026-04-10',
                dateEnd: '2026-04-15',
                origin: 'Минск',
                destination: 'Милан',
                tour_type: 'Шоппинг',
                isHot: false,
                price: 80000,
                discountPrice: null
            },
            {
                name: 'Экскурсия по Парижу',
                dateStart: '2026-05-01',
                dateEnd: '2026-05-07',
                origin: 'Минск',
                destination: 'Париж',
                tour_type: 'Экскурсия',
                isHot: false,
                price: 120000,
                discountPrice: 100000
            },
            {
                name: 'Турция Анталья',
                dateStart: '2026-06-15',
                dateEnd: '2026-06-25',
                origin: 'Минск',
                destination: 'Анталья',
                tour_type: 'Отдых',
                isHot: true,
                price: 60000,
                discountPrice: 55000
            }
        ]);

        app.listen(3000, () => console.log('Server started on port 3000'));
    } catch (e) {
        console.log(e);
    }
};

start();


---

package.json

{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.0",
    "mysql2": "^3.15.3",
    "sequelize": "^6.37.7"
  }
}


--




выше я описал как работает мой бэк. сделай фронт который полностью покрывает возможности бэка. непиши комментарии. не используй стейт менеджеры и useContext, хрни все данные в корне App.js и прокидывай другим комопнентам. пиши максимально тупо и просто. сохраняй при первом входе в аккаунт данные в ocalStorage.

вот шаблон фронта

./tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
    content: [
        "./index.html",
        "./src/**/*.{js,ts,jsx,tsx}"
    ],
    theme: {
        extend: {
            colors: {
                "theme": "#2e0228", 
                "theme-hover": "#4a0440",
                "accent": "#00ff9d",
                "accent-hover": "#5effc4",
                "gray-light": "#fdf2f8",
                "gray-medium": "#9d5c88",
            }
        },
    },
    plugins: [],
};

---
./eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

---
./package.json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.68.0",
    "react-router-dom": "^7.10.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "vite": "^7.2.4"
  }
}

---
./index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/js.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ТЗ_JS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

---
./vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

---
./postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

---
./src/reset.css
*,
*::before,
*::after {
  box-sizing: border-box;
}

html {
  -moz-text-size-adjust: none;
  -webkit-text-size-adjust: none;
  text-size-adjust: none;
}

body, h1, h2, h3, h4, p,
figure, blockquote, dl, dd {
  margin: 0;
}

ul[role='list'],
ol[role='list'] {
  list-style: none;
}

body {
  min-height: 100vh;
  line-height: 1.5;
}

h1, h2, h3, h4,
button, input, label {
  line-height: 1.1;
}

h1, h2,
h3, h4 {
  text-wrap: balance;
}

a:not([class]) {
  text-decoration-skip-ink: auto;
  color: currentColor;
}

img,
picture {
  max-width: 100%;
  display: block;
}

input, button,
textarea, select {
  font: inherit;
}

textarea:not([rows]) {
  min-height: 10em;
}

:target {
  scroll-margin-block: 5ex;
}
---
./src/App.css
#root {
    margin: 0 auto;
    text-align: center;
    max-width: screen;
}

---
./src/App.jsx
import { Routes, Route } from "react-router-dom";
import ClientsPage from "./pages/clients/ClientsPage.jsx";
import ServicesPage from "./pages/services/ServicesPage";
import LinkCustom from "./components/ui/LinkCustom";

function App() {

    return (
        <div className="p-3">
            <nav className="bg-theme h-14 rounded-md flex flex-row items-center justify-center">
                <LinkCustom to="/">Клиенты</LinkCustom>
                <LinkCustom to="/services">Услуги</LinkCustom>
            </nav>

            <Routes>
                <Route path="/" element={<ClientsPage/>} />
                <Route path="/services" element={<ServicesPage/>} />
            </Routes>
        </div>
    );
}

export default App;

---
./src/main.jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import "./index.css";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
    <StrictMode>
        <BrowserRouter>
            <App />
        </BrowserRouter>
    </StrictMode>
);

---
./src/index.css
@import url("./reset.css");
@import url("./App.css");
@tailwind base;
@tailwind components;
@tailwind utilities;


---
./src/pages/services/ServicesPage.jsx
import React from 'react'

export default function ServicesPage() {
  return (
    <div>
      ServicesPage
    </div>
  )
}

---
./src/pages/clients/ClientsPage.jsx
import React from 'react'

export default function ClientsPage() {
  return (
    <div>
      ClientsPage
    </div>
  )
}

---
./src/components/modals/ArertModal.jsx
import Button from "../ui/Button";
import X from "../ui/X";

export default function AlertModal({ isVisible, setIsVisible, alertText }) {

    if (!isVisible) return null;

    return (
        <div
            onClick={() => {
                setIsVisible(false);
            }}
            className="fixed transition inset-0 flex backdrop-blur-sm items-center justify-center bg-gray-medium/50 z-50"
        >
            <div
                onClick={(e) => e.stopPropagation()}
                className="bg-white p-6 rounded-lg shadow-xl relative pt-9 flex flex-col"
            >
                <X
                    className={"absolute top-2 right-2"}
                    onClick={() => {
                        setIsVisible(false);
                    }}
                />

                <h3 className="text-xl font-semibold mb-6 text-center mt-6">{alertText}</h3>

                <Button
                    className="mt-2"
                    onClick={() => { setIsVisible(false); }}
                >
                    Закрыть
                </Button>
            </div>
        </div>
    );
}

---
./src/api/axiosConfig.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:5000',
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api
---
./src/utils/formatters.js
export const formatDate = (dateString) => {
    if (!dateString) return "—";
    return new Date(dateString).toLocaleDateString('ru-RU');
};

---
